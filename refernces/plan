### inbox


---
- 내일 또볼 내용 감편하게 내일 일기로 넘기기
- **사용자 경험의 순서 및 큰 틀**
- 삭제 이유: 뭔가 관계를  삭제하면 로그로 삭제 이유를 남겨야 함. 일기에 자동 등록
- 브레인스토밍
- 지식저장
- 할일관리
- 캘린더
- 자신의 컨텐츠로 활용 가능.
- 플랫폼
	- 모바일
	- pc
	- pad
- 금전관리 -> 토스연동
- 어떤것을 담당하냐: 할일관리 + 개인지식관리 + 캘린더 + 일기 + 금전(예산산출, 재산예측) + 타앱과의 연동
- For Need 커뮤니티
	- 직업별 사용습관 추적
	- 템플릿 마켓
	- 나는 어떤걸 카드로 쓴다.
	- 언어사용량 추적
- ai 결합 가능성
- 연구적 가치: 모든 문장은 주체 행위 객체로 이루어져 있음.
---
# 개요
ForNeed 는 논리관계형 메모앱이다. 메모와 메모간에 관계를 명시함으로써 많은 기능을 가능케 함에서 떠올리게 되었다.
이 어플로는 프로젝트 관리, 인생관리, 플래닝, 할일관리 전부 가능 하다.
[[second brain diagram.excalidraw]]




## 개발동기 및 배경

행복이란 무엇일까, 어떻게 하면 목표를 망각하지않고 계속 맘편히 달릴 수 있을까? 어떻게 하면 주도적으로 살아갈 수 있을까? 에 대한 질문을 끊임없이 던져온 것 같습니다. 스스로 판단하고 질문하는 주도적인 삶  


해야 할일이 너무 많아서. 모든 계획을 머릿속에 넣어두고 싶지 않아서. 
- 계획짜기의 불편함을 너무 많이 느낌
	- 어떤 불편함?
- 긴 컨텍스트 다루기 어려움. 의사결정시 뒷받침 근거의 부재.
- 할일이 많았다. 이루고 싶은것도 많았고, 근데 뭐부터 해야 할지 모르겠다. 
- 제텔카스텐의 한계: 뭐 일단 쓰기는 했는데 어디에 어떻게 붙혀야 할지 모르겠음. -> 더미메모의 증가
- 플래닝 시간 최소화.


후회 반복. 
## 철학

기획자의 철학.

1. 지식관리와 할일관리는 통합되어야 한다: 일기를 쓸때 피드백이 이루어지고 이는 할일을 통해 행동으로 이어져야 하기 때문이다. 특히 PARA 기법의 AREA 같이 반복되는 항목은 더욱 더 습관화 시켜야 하는 부분이다. 단순히 "이래야겠다"라고 적는 것으로는 행동으로 이어지기 어렵다. 모든 분야가 활성화가 되어있는지 알아야 한다.

2. 모든 행동은 뭘 위한것이고 무엇을 필요로하는지 필요충분관계를 가진다. 이는 절대적이지 않고 사용자마다 다른 내용과 의견을 지니지만 그에대해 사용자는 규명해여 언어로써 인지하고 있어야 한다. 더 나아가 선후관계, 포함소속관계 등 다양하게 객체와 객체들은 관계를 지니게 된다.
[[ForNeed 정규화 for ForNeed python]]
3. 한개의 노드는 여러개를 위할 수 있다. 트리구조로 이어지는 할일들은 프로젝트의 구조를 확실하게 하지만, 이는 유연성을 해치게 된다. 똑같은 요소가 여러개의 영향을 미칠 수 있고, 이것은 요소에 가중치를 계산할 수 있게 해주어 의사결정에 있어 중요한 기능을 할 수 있게된다.
4. 입력도 수정도 숏폼처럼: 긴 컨텍스트를 최대한 간편하게 다루게 한다.
	1. 중간 삽입가능: 연결리스트의 장점을 떠올리면 된다.
	2.  
5. 메모앱은 쉬워야 한다: 쉽다는 것은 직관적인 것. 딱 보았을때 아 이렇게 하면 되는구나. 
	1. 기능이 많다 != 사용하기 어렵다: "기능이 많다" 라는 사실 자체로는 좋은 것임. 단지 기능이 많을 수록 뭐를 어떻게 써야할지 감이 안오는 것. 메모앱의 목적은 생각 정리이지만, 오히려 생각이 많아지는 모순에 빠져버림.
6. 중요한것도 망각이 가능하다.
## 문제인식, 원인, 해결방법
- 단순히 생각날때 써놓고 후에 한번에 하는 것은 한계가 있음.
- 맥락의 상실: 어떤 것을 하기 위해 왜 하는지를 망각.
- 재판단 피로: 이미 적어둔 아이디어를 실행하려 할 때, 다시 구조를 파악하고 관계를 정리하는 과정에서 반복적인 인지적이 피로가 발생
- 분리된 생태계: 짧은 루틴, 단순 할일, 전부 따로따로 관리
- 더미메모의 증가: 불필요한 메모의 증가, 어떤 메모가 필요 없고, 어떤메모가 필요한 것인지 관리 고통
- 적은 메모를 실용적으로 활용하기엔 무리가 있음.
- 단절된 생태계

## 기대효과 및 효능
어디에 쓰일 수 있는가?
창업.

텍스트 내보내기를 통해

### 세컨드 브레인으로서

### 할일관리 앱으로서

### 프로젝트 매니징 툴로서

### 일기로서의 효능
- 그때 왜 그런 판단을 했고 이쪽으로 갔었으면 더 좋았고. 그런거 추억거리 삼아 확인 가능
- 일기에서 느낀점을 바로 프로젝트로 적용 가능.
- 일기에서 할일 바로 추가가능
### 사용자 데이터 보유 가능

### 커뮤니케이션 용이
교육, 진로설정 등

### 뼈대 프롬프트 for LLM
자소서, 소설 등을 생각할때 중심을 잡아두면 LLM의 개입 없어짐. But 그 중심을 매번 잡아주기 귀찮음.

?? 그럼 맞춤설정을 사용하면 되지 않는가?
-> 지시패널은 빠르게 접근 불가
-> 맞춤설정의 용도와는 맞지 않음
	?? 그러면 프로젝트 지시 를 쓰면 되지 않느기?
	-> 프로젝트 폴더 안에서는 고성능 모델 사용 불가.

# 관계의 중요성
관계를 명시해야만 기능을 추가할 수 있고
원하는데로 필터링 가능하다

## 관계명시의 목적
- 당장 실행 가능한 행동단위 추출
# Chat GPT랑 다른게 뭐냐?
- 빠름. 불필요한 계산 방지.
- 로컬로도 돌아감. 
- 시각화 가능: LLM들 또한 시각화 처리가 가능하지만 글자 생성오류가 심함. 
- 보안: 로컬 LLM을 사용하는것으로 이 문제는 해결 가능하나, 비용이 많이 들고 
- 안정성: 

• ⁃ 할루시네이션 감소: LLM 은 진실을 말하는 존재가 아닌 데이터를 통해 가장 그럴듯한 말을 지어내는 존재. 이는 LLM의 본질적인 한계. 사용자의 독창성, 통찰을 방해.
# ForNeed

## 핵심 데이터
핵심데이터는 5가지다.
1. 카드
2. 카드타입
3. 관계
4. 관계타입
5. 프로젝트 


생성순서: 카드타입테이블 -> 프로젝트테이블 -> 카드테이블 -> 관계타입테이블 -> 관계테이블

~~~js

db.exec(`

CREATE TABLE IF NOT EXISTS CARDTYPES (

cardtype_id TEXT PRIMARY KEY,

cardtype_name TEXT UNIQUE NOT NULL,

createdat TEXT

)

`);

  

// 프로젝트 테이블 생성

db.exec(`

CREATE TABLE IF NOT EXISTS PROJECTS (

project_id TEXT PRIMARY KEY,

project_name TEXT NOT NULL,

createdat TEXT

)

`);

  

// 카드 테이블 생성

db.exec(`

CREATE TABLE IF NOT EXISTS CARDS (

id TEXT PRIMARY KEY,

project_id TEXT DEFAULT NULL,

title TEXT NOT NULL,

content TEXT,

cardtype TEXT DEFAULT NULL,

complete INTEGER DEFAULT 0,

activate INTEGER DEFAULT 0,

duration INTEGER,

es TEXT,

ls TEXT,

startdate TEXT,

enddate TEXT,

price INTEGER,

createdat TEXT,

FOREIGN KEY (project_id) REFERENCES PROJECTS(project_id) ON DELETE CASCADE,

FOREIGN KEY (cardtype) REFERENCES CARDTYPES(cardtype_id) ON DELETE SET NULL

)

`);

  

// 관계타입 테이블 생성

db.exec(`

CREATE TABLE IF NOT EXISTS RELATIONTYPE (

relationtype_id INTEGER PRIMARY KEY AUTOINCREMENT,

typename TEXT NOT NULL,

oppsite TEXT NOT NULL,

createdat TEXT

)

`);

  

// 관계 테이블 생성

db.exec(`

CREATE TABLE IF NOT EXISTS RELATION (

relation_id INTEGER PRIMARY KEY AUTOINCREMENT,

relationtype_id INTEGER NOT NULL,

source TEXT NOT NULL,

target TEXT NOT NULL,

project_id TEXT NOT NULL,

createdat TEXT,

set INTEGER,

FOREIGN KEY (relationtype_id) REFERENCES RELATIONTYPE(relationtype_id) ON DELETE CASCADE,

FOREIGN KEY (source) REFERENCES CARDS(id) ON DELETE CASCADE,

FOREIGN KEY (target) REFERENCES CARDS(id) ON DELETE CASCADE

)

`);
~~~

### 1. Cards (카드)

#### 📄 CARDS 테이블

| column      | datatype          | 설명                         |     |
| ----------- | ----------------- | -------------------------- | --- |
| id          | TEXT PRIMARY KEY  | 카드 고유 ID (UUID)            |     |
| project_id  | TEXT NOT NULL     | 프로젝트 ID (FK)               |     |
| title       | TEXT NOT NULL     | 카드 제목                      |     |
| content(메모) | TEXT              | 카드 내용 (선택)                 |     |
| cardtype    | TEXT              | 카드 타입 (ex: "noun", "task") |     |
| complete    | INTEGER DEFAULT 0 | 완료 여부 (0: 미완료, 1: 완료)      |     |
| activate    | INTEGER DEFAULT 0 | 진행 여부 (0: 비활성, 1: 활성)      |     |
| duration    | INTEGER           | 소요 시간 (시간 단위)              |     |
| es          | TEXT              | Earliest Start (ISO 8601)  |     |
| ls          | TEXT              | Latest Start               |     |
| startdate   | TEXT              | 실제 시작일시                    |     |
| enddate     | TEXT              | 실제 종료일시                    |     |
| price       | INTEGER           | 비용                         |     |
| createdat   | TEXT              | 생성일시 (ISO 8601)            |     |



---
### 2. Cardtypes (카드 타입)

카드에 속성을 부여하므로써 맵상에서 다르게 보이게 가능

1. 특수카드타입(기본카드타입): 카드 타입에 따라 기능을 달리함. 
- 각 카드 타입별 특징
	- entity(물건, 자격증, 개체):  가격정보를 사용함
	- habit(습관): 활성 비활성화 기능을 제공함
	- action(행동):  기존어플들의 ToDo 에 가까운 카드로, 완료 비완료
	- destination(목표): 행동보다는 좀더 거대한 목표. 성공 비성공 이 뚜렷하게 구분지을 수 있는 것.
	- IF(조건분기): 일명 가능세계, 브랜치. 이 카드를 기점으로 가능세계 관찰 가능. 만약에 카드로 맵 상에서 좀더 직관적으로 어느선택이 더 나을지 선택하는 역할을 함.

2. 사용자 설정 카드타입: 사용자는 새로운 카드타입을 정의 할 수 있음. 하지만 그 관계는 아무 기능도 하지 않음. 색상, 카드타입 명 등 눈에 보이는 것만 지정 가능함


#### 📄 CARDTYPES 테이블

| column        | datatype             | 설명           |
| ------------- | -------------------- | ------------ |
| cardtype_id   | TEXT PRIMARY KEY     | 카드타입 고유 ID   |
| cardtype_name | TEXT UNIQUE NOT NULL | 카드타입 이름 (고유) |
| createdat     | TEXT                 | 생성일시         |
|               |                      |              |
### Cardtype 테이블 예시 데이터

| project |     |     |
| ------- | --- | --- |
|         |     |     |
|         |     |     |




---
### 3. Relationtype(관계타입)
ForNeed 에서 가장 중요한 기능으로 카드와 카드간 관계를 명시적으로 정의함.
카드타입과 마찬가지로 
- 기본제공 관계타입. 기능. 특징
	- For-Need: 필요 충분 조건. 이 앱의 상징적인 관계타입. entity의 금액정보를 추산하기 위한 핵심적인 기능.
	- Before-After: 프로젝트 진행상 무엇이 선생되는지 위배되지는 않는지 확인용. 한개의 일정을 변경할때 후속되는 일정 시간정보를 연쇄적으로 변환시키기 위한 핵심 관계타입.
	- Related to - Related to: 일반 연관기능 딱히 특정한 관계를 떠올리기 힘들때
	- incompatible with - incompatible with: 프로젝트에서 동시에 진행 불가능한 관계
- 사용자 설정 관계타입: 아무런 기능도 하지 않음. 참고용 다만 방향은 존재하며 맵에서 얼마든지 가중치와 필터링을 이용해 직관적 관계 파악 가능. 
	- So - because:
	- For-Need: 필요 충분 조건

관계타입을 생성하면 반대 관계타입도 무조건 생성해야 함. 관계타입은 무조건 두개가 한쌍으로 관리 되어야 한다.


#### 📄 RELATIONTYPE 테이블

| column          | datatype                          | 설명                                       |
| --------------- | --------------------------------- | ---------------------------------------- |
| relationtype_id | INTEGER PRIMARY KEY AUTOINCREMENT | 관계 타입 고유 ID                              |
| typename        | TEXT UNIQUE NOT NULL              | 관계 이름 ("for", "need", "before", "after") |
| oppsite         | TEXT UNIQUE NOT NULL              | 반대 관계타입. FK 그 관계                         |
| matingNum       | INTEGER AUTOINCREMENT             | 짝이된느 관계와 함께 공유하는 숫자                      |



#### **RELATIONTYPE 예시 데이터**

| relationtype_id | typename |
| --------------- | -------- |
| 1               | for      |
| 2               | need     |
| 3               | before   |
| 4               | after    |

---

### 4. Relation (관계) 
현재 맺어져 있는 관계 현광을 나타내는 데이터.

#### 📄 RELATION 테이블

| column          | datatype                          | 설명                                 |         |
| --------------- | --------------------------------- | ---------------------------------- | ------- |
| relation_id     | INTEGER PRIMARY KEY AUTOINCREMENT | 관계 고유 ID                           |         |
| relationtype_id | INTEGER NOT NULL                  | 관계 타입 ID (FK)                      | null 가능 |
| source          | TEXT NOT NULL                     | 출발 카드 ID (FK)                      | cascade |
| target          | TEXT NOT NULL                     | 도착 카드 ID (FK)                      | cascade |
| project_id      | TEXT NOT NULL                     | 프로젝트 ID (FK)                       | cascade |
| createdat       | TEXT                              | 생성일시                               |         |
| set             | Integer                           | auto increment  oppsite과 한짝이 되기 위함 |         |

### **RELATION 예시 데이터**

| relation_id | relationtype_id | source | target |
| ----------- | --------------- | ------ | ------ |
| 돈벌기         | 1 (for)         | 13     | 12     |
| 2           | 2 (need)        | 12     | 13     |

---


## 기능

### 아무관계도 없는 노트 띄우기

### 랜덤노트
숏폼 랜덤노트

### 일기
행바꿈을 할때마다 시각 표시
옵시디언에 왼쪽에 몇번째 행인지 표시되는 칸처럼 그거 대신에 시각을 집어넣게끔

이렇게 하면 일기 데이터 분석 가능. 
루틴 파악 가능.

주간보고, 월간보고, 여간보고 자동화 가능.

- ps. 2025.06.06. 1727i
	- 포니드 일기 기능으로 사용가능할듯.



[[평균적으로 n일씩 늦어지고  있습니다]]
### 그래프뷰
- 필터링
	- 특정 관계만 필터링
	- 아무 관계도 가지지 않는 카드 필터링
	- 특정 카드타입만 필터링
	- 필터링 상태 저장
- 특정 값이 비어있는 카드만 필터링
- 참조: 맵이 무방비하게 커지면 오히려 가시성이 좋지 않음.
- 내보내기: 그래프뷰 현 상태를 png, jpeg 등으로 내보낼 수 있겠끔. 


- CRUD 조작
	- 여백 공간 더블클릭시 카드 생성
		- 팝아웃으로 조그마한 창 생성해서 디테일 조정
	- 드래그로 노드 끼리 연결시 관계 생성

### 관계설정
#### 기본제공 관계타입
#### 사용자 지정관계타입
#### 메타관계
() 카드
{} 관계
관계에 대한 관계 또한 가능하다.
예를 들면 {(A) Need (B)} 를 추가하면 (A Need B)라는 카드가 하나 더 생겨나서 {(A Need B) Because (C)} 가 가능해진다. 그 다음에는 ( (A Need B) Because C) 라는 카드가 하나 더 생기게 된다. 

이렇게 되면 CardTable에서 이것이 단일카드인지 메타관계를 담은 카드인지 구별할 수 있는 애트리뷰트를 추가해야 한다. 이는 기본카드타입
### 반응형 PERT/CPM
### 캘린더 자동배치
### AI와의 결합가능성
- 자연어 -> ForNeed data로 변환: 사용편의성 증가, 다른 어플리케이션에서 ForNeed 로 이동시 마이그레이션 원활
- 일기로 하루 검토 -> AI가 일기 인식 후 제안. ex) 하루중 휴식시간이 너무 적은 것 같습니다. 학습을 끝낸 직후 어떤 것을 하셨나요?
- 연결상태 검토.
- 개인 데이터 분석
- 해쉬태그 사용하지 않고 관련 노트 추천

• 프로그램상 미리 입력된 일기전용 프롬프트 that refer 인지심리학.
## UX/UI
- 영감
	- 회색 톤.
- 테마 사용자 지정 가능.


# 구현
## 현재 구현 상태
## 개발 계획

# 시장조사

## 시장환경

## 경쟁사

### ForNeed 의 포지션

# 사업화 계획
## 수익모델

## 지식재산
### 특허
#### **1. 관계 기반 입력 구조**

- **내용:** 단순 메모가 아닌 For–Need–Before–After 관계 입력
    
- **차별점:** 목표–선행–조건 등 복합적 논리 구조
    
- **가능성:** **높음** – 입력 방식 + 저장 구조 + 시각화 로직이 조합될 경우

### **2. 자동 일정 계획 (PERT/CPM)**

- **내용:** 관계 기반 입력만으로 일정 자동 계산
    
- **기능:** 데드라인 자동 산출, 변경 시 연쇄 재계산
    
- **가능성:** **높음** – 독자적 알고리즘이 있으면 특허화 유리


### **3. 중력 기반 시각화**

- **내용:** 중요도(중력 값)를 기준으로 노드를 배치
    
- **차별점:** 관계 유형에 따라 배치 규칙이 달라짐
    
- **가능성:** **중간 ~ 높음** – 단순 D3.js 사용은 해당 안 되나, 자체 배치 알고리즘이 있으면 유리
#### **4. 통합 카드 입력 UI**

- **내용:** 카드 작성 + 관계 지정 + 연결 대상 선택을 하나의 인터페이스에서 처리
    
- **차별점:** 대부분의 메모앱은 비연결형 텍스트 위주
    
- **가능성:** **중간** – 관계형 입력 흐름과 실시간 반응 구조가 독창적이면 가능
#### **5. 메타관계 처리 (관계의 관계)**

- **내용:** 예: 관계{A→B}가 관계{C→D}의 원인이라는 다층 구조
    
- **차별점:** 관계형 DB + 그래프 모델 혼합
    
- **가능성:** **중간 ~ 높음** – 다층 관계 추론 로직이 존재할 경우
## 마케팅

[[ForNeed 마케팅 라인]]

### 마케팅 방안
- sns 홍보
### 타겟고객






# 팀원 모집
1. 디자이너. ux/ui 디자이너
	1. 요구역량: 피그마
2. 프론트 개발자:
	1. 요구역량: 리액트. 일렉트론. node.js 능숙
3. 백엔드 개발자:
	1. 서비스화 경험


**AI를 사용하면서 개인정보 보호를 지키는 법:**

• ⁃ 로컬 llm (로컬LLM 용량 및 사양 알아보기) 8B 모델 매개변수 80억개정도면 충분히 일반사용자의 로컬에서 구동 가능한 어플리케이션.